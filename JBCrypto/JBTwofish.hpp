//------------------------------------------------------------------------------------------------------
// Twofish C++ port based on Bruce Schneier's reference C implementation
// https://www.schneier.com/academic/twofish/
// (w) 2025 Jan Buchholz
//------------------------------------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <vector>
#include <string>
#include "../JBCommon/JBCommon.hpp"

constexpr uint32_t TWOFISH_KEY_SIZE = 32;
constexpr uint32_t TWOFISH_BLOCK_SIZE = 16;

constexpr uint8_t TFQ0ARRAY[] = {
    0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76, 0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38,
    0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c, 0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48,
    0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23, 0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82,
    0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c, 0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61,
    0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b, 0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1,
    0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66, 0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7,
    0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba, 0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71,
    0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8, 0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7,
    0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2, 0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90,
    0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab, 0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef,
    0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b, 0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64,
    0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a, 0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a,
    0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02, 0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d,
    0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72, 0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,
    0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8, 0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4,
    0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00, 0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0
};
constexpr uint8_t TFQ1ARRAY[] = {
    0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8, 0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b,
    0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1, 0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f,
    0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d, 0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5,
    0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3, 0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51,
    0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96, 0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c,
    0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70, 0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8,
    0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc, 0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2,
    0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9, 0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17,
    0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3, 0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e,
    0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49, 0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9,
    0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01, 0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48,
    0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19, 0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64,
    0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5, 0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69,
    0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e, 0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc,
    0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab, 0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9,
    0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91
};
constexpr uint8_t TFQ2ARRAY[] = {
    0x00, 0x5b, 0xb6, 0xed, 0x05, 0x5e, 0xb3, 0xe8, 0x0a, 0x51, 0xbc, 0xe7, 0x0f, 0x54, 0xb9, 0xe2,
    0x14, 0x4f, 0xa2, 0xf9, 0x11, 0x4a, 0xa7, 0xfc, 0x1e, 0x45, 0xa8, 0xf3, 0x1b, 0x40, 0xad, 0xf6,
    0x28, 0x73, 0x9e, 0xc5, 0x2d, 0x76, 0x9b, 0xc0, 0x22, 0x79, 0x94, 0xcf, 0x27, 0x7c, 0x91, 0xca,
    0x3c, 0x67, 0x8a, 0xd1, 0x39, 0x62, 0x8f, 0xd4, 0x36, 0x6d, 0x80, 0xdb, 0x33, 0x68, 0x85, 0xde,
    0x50, 0x0b, 0xe6, 0xbd, 0x55, 0x0e, 0xe3, 0xb8, 0x5a, 0x01, 0xec, 0xb7, 0x5f, 0x04, 0xe9, 0xb2,
    0x44, 0x1f, 0xf2, 0xa9, 0x41, 0x1a, 0xf7, 0xac, 0x4e, 0x15, 0xf8, 0xa3, 0x4b, 0x10, 0xfd, 0xa6,
    0x78, 0x23, 0xce, 0x95, 0x7d, 0x26, 0xcb, 0x90, 0x72, 0x29, 0xc4, 0x9f, 0x77, 0x2c, 0xc1, 0x9a,
    0x6c, 0x37, 0xda, 0x81, 0x69, 0x32, 0xdf, 0x84, 0x66, 0x3d, 0xd0, 0x8b, 0x63, 0x38, 0xd5, 0x8e,
    0xa0, 0xfb, 0x16, 0x4d, 0xa5, 0xfe, 0x13, 0x48, 0xaa, 0xf1, 0x1c, 0x47, 0xaf, 0xf4, 0x19, 0x42,
    0xb4, 0xef, 0x02, 0x59, 0xb1, 0xea, 0x07, 0x5c, 0xbe, 0xe5, 0x08, 0x53, 0xbb, 0xe0, 0x0d, 0x56,
    0x88, 0xd3, 0x3e, 0x65, 0x8d, 0xd6, 0x3b, 0x60, 0x82, 0xd9, 0x34, 0x6f, 0x87, 0xdc, 0x31, 0x6a,
    0x9c, 0xc7, 0x2a, 0x71, 0x99, 0xc2, 0x2f, 0x74, 0x96, 0xcd, 0x20, 0x7b, 0x93, 0xc8, 0x25, 0x7e,
    0xf0, 0xab, 0x46, 0x1d, 0xf5, 0xae, 0x43, 0x18, 0xfa, 0xa1, 0x4c, 0x17, 0xff, 0xa4, 0x49, 0x12,
    0xe4, 0xbf, 0x52, 0x09, 0xe1, 0xba, 0x57, 0x0c, 0xee, 0xb5, 0x58, 0x03, 0xeb, 0xb0, 0x5d, 0x06,
    0xd8, 0x83, 0x6e, 0x35, 0xdd, 0x86, 0x6b, 0x30, 0xd2, 0x89, 0x64, 0x3f, 0xd7, 0x8c, 0x61, 0x3a,
    0xcc, 0x97, 0x7a, 0x21, 0xc9, 0x92, 0x7f, 0x24, 0xc6, 0x9d, 0x70, 0x2b, 0xc3, 0x98, 0x75, 0x2e
};
constexpr uint8_t TFQ3ARRAY[] = {
    0x00, 0xef, 0xb7, 0x58, 0x07, 0xe8, 0xb0, 0x5f, 0x0e, 0xe1, 0xb9, 0x56, 0x09, 0xe6, 0xbe, 0x51,
    0x1c, 0xf3, 0xab, 0x44, 0x1b, 0xf4, 0xac, 0x43, 0x12, 0xfd, 0xa5, 0x4a, 0x15, 0xfa, 0xa2, 0x4d,
    0x38, 0xd7, 0x8f, 0x60, 0x3f, 0xd0, 0x88, 0x67, 0x36, 0xd9, 0x81, 0x6e, 0x31, 0xde, 0x86, 0x69,
    0x24, 0xcb, 0x93, 0x7c, 0x23, 0xcc, 0x94, 0x7b, 0x2a, 0xc5, 0x9d, 0x72, 0x2d, 0xc2, 0x9a, 0x75,
    0x70, 0x9f, 0xc7, 0x28, 0x77, 0x98, 0xc0, 0x2f, 0x7e, 0x91, 0xc9, 0x26, 0x79, 0x96, 0xce, 0x21,
    0x6c, 0x83, 0xdb, 0x34, 0x6b, 0x84, 0xdc, 0x33, 0x62, 0x8d, 0xd5, 0x3a, 0x65, 0x8a, 0xd2, 0x3d,
    0x48, 0xa7, 0xff, 0x10, 0x4f, 0xa0, 0xf8, 0x17, 0x46, 0xa9, 0xf1, 0x1e, 0x41, 0xae, 0xf6, 0x19,
    0x54, 0xbb, 0xe3, 0x0c, 0x53, 0xbc, 0xe4, 0x0b, 0x5a, 0xb5, 0xed, 0x02, 0x5d, 0xb2, 0xea, 0x05,
    0xe0, 0x0f, 0x57, 0xb8, 0xe7, 0x08, 0x50, 0xbf, 0xee, 0x01, 0x59, 0xb6, 0xe9, 0x06, 0x5e, 0xb1,
    0xfc, 0x13, 0x4b, 0xa4, 0xfb, 0x14, 0x4c, 0xa3, 0xf2, 0x1d, 0x45, 0xaa, 0xf5, 0x1a, 0x42, 0xad,
    0xd8, 0x37, 0x6f, 0x80, 0xdf, 0x30, 0x68, 0x87, 0xd6, 0x39, 0x61, 0x8e, 0xd1, 0x3e, 0x66, 0x89,
    0xc4, 0x2b, 0x73, 0x9c, 0xc3, 0x2c, 0x74, 0x9b, 0xca, 0x25, 0x7d, 0x92, 0xcd, 0x22, 0x7a, 0x95,
    0x90, 0x7f, 0x27, 0xc8, 0x97, 0x78, 0x20, 0xcf, 0x9e, 0x71, 0x29, 0xc6, 0x99, 0x76, 0x2e, 0xc1,
    0x8c, 0x63, 0x3b, 0xd4, 0x8b, 0x64, 0x3c, 0xd3, 0x82, 0x6d, 0x35, 0xda, 0x85, 0x6a, 0x32, 0xdd,
    0xa8, 0x47, 0x1f, 0xf0, 0xaf, 0x40, 0x18, 0xf7, 0xa6, 0x49, 0x11, 0xfe, 0xa1, 0x4e, 0x16, 0xf9,
    0xb4, 0x5b, 0x03, 0xec, 0xb3, 0x5c, 0x04, 0xeb, 0xba, 0x55, 0x0d, 0xe2, 0xbd, 0x52, 0x0a, 0xe5
};
constexpr uint8_t TFRSARRAY[4][8] = {
    {0x01, 0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e,},
    {0xa4, 0x56, 0x82, 0xf3, 0x1e, 0xc6, 0x68, 0xe5,},
    {0x02, 0xa1, 0xfc, 0xc1, 0x47, 0xae, 0x3d, 0x19,},
    {0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e, 0x03}
};

constexpr uint32_t RS_MOD = 0x014d;
constexpr uint32_t RHO = 0x01010101;

inline uint32_t tfk0array[40] = {};
inline uint8_t tfq0array[std::size(TFQ0ARRAY)];
inline uint8_t tfq1array[std::size(TFQ1ARRAY)];
inline uint8_t tfq2array[std::size(TFQ2ARRAY)];
inline uint8_t tfq3array[std::size(TFQ3ARRAY)];
inline uint32_t tfqfarray[4][std::size(TFQ0ARRAY)];
inline uint32_t tfs0array[4];

inline uint32_t polyMultiply(uint32_t a, uint32_t b) {
    uint32_t t = 0;
    while (a != 0) {
        if ((a & 0x01) != 0) t ^= b;
        b <<= 1;
        a >>= 1;
    }
    return t;
}

inline uint32_t gfMod(uint32_t a, uint32_t m) {
    m <<= 7;
    for (int i = 0; i < 8; i++) {
        if (const uint32_t x = a ^ m; x < a) a = x;
        m >>= 1;
    }
    return a;
}

inline uint32_t gfMultiply(uint32_t a, uint32_t b, uint32_t m) {
    return gfMod(polyMultiply(a, b), m);
}

inline uint32_t rsMatrixMultiply(const uint8_t *c) {
    uint8_t r[4];
    for (int j = 0; j < 4; j++) {
        uint8_t t = 0;
        for (int k = 0; k < 8; k++) t ^= gfMultiply(TFRSARRAY[j][k], c[k], RS_MOD);
        r[3 - j] = t;
    }
    return static_cast<uint32_t>((r[0] << 24) ^ (r[1] << 16) ^ (r[2] << 8) ^ r[3]);
}

inline uint32_t gFunc(uint32_t a) {
    return tfqfarray[0][a & 0xff] ^ tfqfarray[1][(a >> 8) & 0xff] ^
           tfqfarray[2][(a >> 16) & 0xff] ^ tfqfarray[3][(a >> 24) & 0xff];
}

inline uint32_t hFunc(uint32_t a, const uint32_t *x) {
    uint8_t y0 = a;
    uint8_t y1 = a >> 8;
    uint8_t y2 = a >> 16;
    uint8_t y3 = a >> 24;
    y0 = tfq1array[y0] ^ (x[3] & 0xff);
    y1 = tfq0array[y1] ^ ((x[3] >> 8) & 0xff);
    y2 = tfq0array[y2] ^ ((x[3] >> 16) & 0xff);
    y3 = tfq1array[y3] ^ ((x[3] >> 24) & 0xff);
    y0 = tfq1array[y0] ^ (x[2] & 0xff);
    y1 = tfq1array[y1] ^ ((x[2] >> 8) & 0xff);
    y2 = tfq0array[y2] ^ ((x[2] >> 16) & 0xff);
    y3 = tfq0array[y3] ^ ((x[2] >> 24) & 0xff);
    y0 = tfq1array[tfq0array[tfq0array[y0] ^ (x[1] & 0xff)] ^ (x[0] & 0xff)];
    y1 = tfq0array[tfq0array[tfq1array[y1] ^ ((x[1] >> 8) & 0xff)] ^ ((x[0] >> 8) & 0xff)];
    y2 = tfq1array[tfq1array[tfq0array[y2] ^ ((x[1] >> 16) & 0xff)] ^ ((x[0] >> 16) & 0xff)];
    y3 = tfq0array[tfq1array[tfq1array[y3] ^ ((x[1] >> 24) & 0xff)] ^ ((x[0] >> 24) & 0xff)];
    const uint8_t z0 = tfq3array[y0] ^ y1 ^ tfq3array[y2] ^ tfq2array[y3];
    const uint8_t z1 = tfq3array[y0] ^ tfq2array[y1] ^ y2 ^ tfq3array[y3];
    const uint8_t z2 = tfq2array[y0] ^ tfq3array[y1] ^ tfq3array[y2] ^ y3;
    const uint8_t z3 = y0 ^ tfq3array[y1] ^ tfq2array[y2] ^ tfq2array[y3];
    return static_cast<uint32_t>((z0 << 24) ^ (z1 << 16) ^ (z2 << 8) ^ z3);
}

inline void encryptRound(const uint32_t r0, const uint32_t r1, uint32_t *r2, uint32_t *r3, const uint32_t r) {
    const uint32_t t0 = gFunc(r0);
    const uint32_t t1 = gFunc(rol32(r1, 8));
    *r2 = ror32((*r2 ^ (t0 + t1 + tfk0array[2 * r + 8])), 1);
    *r3 = rol32(*r3, 1) ^ (2 * t1 + t0 + tfk0array[2 * r + 9]);
}

inline void decryptRound(const uint32_t r0, const uint32_t r1, uint32_t *r2, uint32_t *r3, const uint32_t r) {
    const uint32_t t0 = gFunc(r0);
    const uint32_t t1 = gFunc(rol32(r1, 8));
    *r2 = rol32(*r2, 1) ^ (t0 + t1 + tfk0array[2 * r + 8]);
    *r3 = ror32((*r3 ^ (t0 + 2 * t1 + tfk0array[2 * r + 9])), 1);
}


inline void TwofishEncryptBase(std::vector<uint8_t> &p) {
    auto r0 = static_cast<uint32_t>(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
    auto r1 = static_cast<uint32_t>(p[4] | (p[5] << 8) | (p[6] << 16) | (p[7] << 24));
    auto r2 = static_cast<uint32_t>(p[8] | (p[9] << 8) | (p[10] << 16) | (p[11] << 24));
    auto r3 = static_cast<uint32_t>(p[12] | (p[13] << 8) | (p[14] << 16) | (p[15] << 24));
    r3 ^= tfk0array[3];
    r2 ^= tfk0array[2];
    r1 ^= tfk0array[1];
    r0 ^= tfk0array[0];
    encryptRound(r0, r1, &r2, &r3, 0);
    encryptRound(r2, r3, &r0, &r1, 1);
    encryptRound(r0, r1, &r2, &r3, 2);
    encryptRound(r2, r3, &r0, &r1, 3);
    encryptRound(r0, r1, &r2, &r3, 4);
    encryptRound(r2, r3, &r0, &r1, 5);
    encryptRound(r0, r1, &r2, &r3, 6);
    encryptRound(r2, r3, &r0, &r1, 7);
    encryptRound(r0, r1, &r2, &r3, 8);
    encryptRound(r2, r3, &r0, &r1, 9);
    encryptRound(r0, r1, &r2, &r3, 10);
    encryptRound(r2, r3, &r0, &r1, 11);
    encryptRound(r0, r1, &r2, &r3, 12);
    encryptRound(r2, r3, &r0, &r1, 13);
    encryptRound(r0, r1, &r2, &r3, 14);
    encryptRound(r2, r3, &r0, &r1, 15);
    r1 ^= tfk0array[7];
    r0 ^= tfk0array[6];
    r3 ^= tfk0array[5];
    r2 ^= tfk0array[4];
    p[0] = r2;
    p[1] = (r2 >> 8);
    p[2] = (r2 >> 16);
    p[3] = (r2 >> 24);
    p[4] = r3;
    p[5] = (r3 >> 8);
    p[6] = (r3 >> 16);
    p[7] = (r3 >> 24);
    p[8] = r0;
    p[9] = (r0 >> 8);
    p[10] = (r0 >> 16);
    p[11] = (r0 >> 24);
    p[12] = r1;
    p[13] = (r1 >> 8);
    p[14] = (r1 >> 16);
    p[15] = (r1 >> 24);
}

inline void TwofishDecryptBase(std::vector<uint8_t> &p) {
    auto r0 = static_cast<uint32_t>(p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24));
    auto r1 = static_cast<uint32_t>(p[4] | (p[5] << 8) | (p[6] << 16) | (p[7] << 24));
    auto r2 = static_cast<uint32_t>(p[8] | (p[9] << 8) | (p[10] << 16) | (p[11] << 24));
    auto r3 = static_cast<uint32_t>(p[12] | (p[13] << 8) | (p[14] << 16) | (p[15] << 24));
    r3 ^= tfk0array[7];
    r2 ^= tfk0array[6];
    r1 ^= tfk0array[5];
    r0 ^= tfk0array[4];
    decryptRound(r0, r1, &r2, &r3, 15);
    decryptRound(r2, r3, &r0, &r1, 14);
    decryptRound(r0, r1, &r2, &r3, 13);
    decryptRound(r2, r3, &r0, &r1, 12);
    decryptRound(r0, r1, &r2, &r3, 11);
    decryptRound(r2, r3, &r0, &r1, 10);
    decryptRound(r0, r1, &r2, &r3, 9);
    decryptRound(r2, r3, &r0, &r1, 8);
    decryptRound(r0, r1, &r2, &r3, 7);
    decryptRound(r2, r3, &r0, &r1, 6);
    decryptRound(r0, r1, &r2, &r3, 5);
    decryptRound(r2, r3, &r0, &r1, 4);
    decryptRound(r0, r1, &r2, &r3, 3);
    decryptRound(r2, r3, &r0, &r1, 2);
    decryptRound(r0, r1, &r2, &r3, 1);
    decryptRound(r2, r3, &r0, &r1, 0);
    r1 ^= tfk0array[3];
    r0 ^= tfk0array[2];
    r3 ^= tfk0array[1];
    r2 ^= tfk0array[0];
    p[0] = r2;
    p[1] = (r2 >> 8);
    p[2] = (r2 >> 16);
    p[3] = (r2 >> 24);
    p[4] = r3;
    p[5] = (r3 >> 8);
    p[6] = (r3 >> 16);
    p[7] = (r3 >> 24);
    p[8] = r0;
    p[9] = (r0 >> 8);
    p[10] = (r0 >> 16);
    p[11] = (r0 >> 24);
    p[12] = r1;
    p[13] = (r1 >> 8);
    p[14] = (r1 >> 16);
    p[15] = (r1 >> 24);
}

inline std::vector<uint8_t> TwofishEncryptECB(const std::vector<uint8_t> &payload) {
    std::vector<uint8_t> result = {};
    const uint64_t l = payload.size();
    uint8_t pad = 0x00;
    uint64_t i = 0, j, k;
    std::vector<uint8_t> pt(TWOFISH_BLOCK_SIZE, 0x00);
    while (i < l) {
        pad = (i + TWOFISH_BLOCK_SIZE < l) ? 0x00 : static_cast<uint8_t>(i + TWOFISH_BLOCK_SIZE - l);
        for (j = i, k = 0; j < i + TWOFISH_BLOCK_SIZE; j++) {
            const uint8_t c = (j < l) ? payload[j] : pad;
            pt[k++] = c;
        }
        i += TWOFISH_BLOCK_SIZE;
        TwofishEncryptBase(pt);
        result.insert(std::end(result), std::begin(pt), std::end(pt));
    }
    if (pad == 0x00) {
        std::vector<uint8_t> vpad(TWOFISH_BLOCK_SIZE, TWOFISH_BLOCK_SIZE);
        TwofishEncryptBase(vpad);
        result.insert(std::end(result), std::begin(vpad), std::end(vpad));
    }
    return result;
}

inline std::vector<uint8_t> TwofishDecryptECB(const std::vector<uint8_t> &payload) {
    std::vector<uint8_t> result = {};
    const uint64_t l = payload.size();
    uint8_t c;
    uint64_t i = 0, j, k;
    std::vector<uint8_t> pt(TWOFISH_BLOCK_SIZE, 0x00);
    while (i < l) {
        for (j = i, k = 0; j < i + TWOFISH_BLOCK_SIZE; j++) {
            c = (j < l) ? payload[j] : 0x00;
            pt[k++] = c;
        }
        i += TWOFISH_BLOCK_SIZE;
        TwofishDecryptBase(pt);
        result.insert(std::end(result), std::begin(pt), std::end(pt));
    }
    j = result.size();
    if (j > 0) {
        if (const uint8_t p = result[j - 1]; (p <= TWOFISH_BLOCK_SIZE) && (p < j)) {
            int z = p;
            c = 0;
            while (z >= 0) {
                if (result[j - z - 1] == p) c++;
                z--;
            }
            if (c == p) result.resize(j - p);
        }
    }
    return result;
}

inline std::vector<uint8_t> TwofishEncryptCBC(const std::vector<uint8_t> &payload,
    const std::vector<uint8_t> &vinit) {
    std::vector<uint8_t> result = {};
    const uint64_t l = payload.size();
    uint8_t pad = 0x00;
    uint64_t i = 0, j, k;
    std::vector<uint8_t> pt(TWOFISH_BLOCK_SIZE, 0x00);
    std::vector<uint8_t> vxor(TWOFISH_BLOCK_SIZE, 0x00);
    if (!vinit.empty()) {
        for (j = 0, k = 0; j < TWOFISH_BLOCK_SIZE; j++) {
            if (k >= vinit.size()) k = 0;
            vxor[j] = vinit[k++];
        }
    }
    while (i < l) {
        pad = (i + TWOFISH_BLOCK_SIZE < l) ? 0x00 : static_cast<uint8_t>(i + TWOFISH_BLOCK_SIZE - l);
        for (j = i, k = 0; j < i + TWOFISH_BLOCK_SIZE; j++) {
            const uint8_t c = (j < l) ? payload[j] : pad;
            pt[k++] = c;
        }
        i += TWOFISH_BLOCK_SIZE;
        for (j = 0; j < TWOFISH_BLOCK_SIZE; j++) pt[j] ^= vxor.at(j);
        TwofishEncryptBase(pt);
        vxor = pt;
        result.insert(std::end(result), std::begin(pt), std::end(pt));
    }
    if (pad == 0x00) {
        std::vector<uint8_t> vpad(TWOFISH_BLOCK_SIZE, TWOFISH_BLOCK_SIZE);
        for (j = 0; j < TWOFISH_BLOCK_SIZE; j++) vpad[j] ^= vxor.at(j);
        TwofishEncryptBase(vpad);
        result.insert(std::end(result), std::begin(vpad), std::end(vpad));
    }
    return result;
}

inline std::vector<uint8_t> TwofishDecryptCBC(const std::vector<uint8_t> &payload,
    const std::vector<uint8_t> &vinit) {
    std::vector<uint8_t> result = {};
    const uint64_t l = payload.size();
    uint8_t c;
    uint64_t i = 0, j, k;
    std::vector<uint8_t> pt(TWOFISH_BLOCK_SIZE, 0x00);
    std::vector<uint8_t> ptmp(TWOFISH_BLOCK_SIZE, 0x00);
    std::vector<uint8_t> vxor(TWOFISH_BLOCK_SIZE, 0x00);
    if (!vinit.empty()) {
        for (j = 0, k = 0; j < TWOFISH_BLOCK_SIZE; j++) {
            if (k >= vinit.size()) k = 0;
            ptmp[j] = vinit[k++];
        }
    }
    while (i < l) {
        for (j = i, k = 0; j < i + TWOFISH_BLOCK_SIZE; j++) {
            c = (j < l) ? payload[j] : 0x00;
            pt[k++] = c;
        }
        i += TWOFISH_BLOCK_SIZE;
        vxor = pt;
        TwofishDecryptBase(pt);
        for (j = 0; j < TWOFISH_BLOCK_SIZE; j++) pt[j] ^= ptmp.at(j);
        ptmp = vxor;
        result.insert(std::end(result), std::begin(pt), std::end(pt));
    }
    j = result.size();
    if (j > 0) {
        if (const uint8_t p = result[j - 1]; (p <= TWOFISH_BLOCK_SIZE) && (p < j)) {
            int z = p;
            c = 0;
            while (z >= 0) {
                if (result[j - z - 1] == p) c++;
                z--;
            }
            if (c == p) result.resize(j - p);
        }
    }
    return result;
}

inline void TwofishInitialize(const std::vector<uint8_t> &p) {
    constexpr int k = 4;
    memcpy(&tfq0array[0], &TFQ0ARRAY[0], std::size(TFQ0ARRAY));
    memcpy(&tfq1array[0], &TFQ1ARRAY[0], std::size(TFQ1ARRAY));
    memcpy(&tfq2array[0], &TFQ2ARRAY[0], std::size(TFQ2ARRAY));
    memcpy(&tfq3array[0], &TFQ3ARRAY[0], std::size(TFQ3ARRAY));
    int i;
    uint32_t mke[4] = {};
    uint32_t mko[4] = {};
    uint32_t key[8] = {};
    uint8_t vec[8] = {};
    uint8_t mkey[TWOFISH_KEY_SIZE] = {};
    int j = 0;
    for (i = 0; i < TWOFISH_KEY_SIZE; i++) {
        if (j >= p.size()) j = 0;
        mkey[i] = p[j++];
    }
    for (i = 0; i < TWOFISH_KEY_SIZE / 4; i++) {
        key[i] = static_cast<uint32_t>((mkey[4 * i + 3] << 24) | (mkey[4 * i + 2] << 16) |
                                       (mkey[4 * i + 1] << 8) | mkey[4 * i]);
    }
    for (i = 0; i < k; i++) {
        mke[i] = key[2 * i];
        mko[i] = key[2 * i + 1];
    }
    for (i = 0; i < k; i++) {
        for (j = 0; j < 4; j++) vec[j] = static_cast<uint8_t>(mke[i] >> (j << 3));
        for (j = 0; j < 4; j++) vec[j + 4] = static_cast<uint8_t>(mko[i] >> (j << 3));
        tfs0array[k - i - 1] = rsMatrixMultiply(vec);
    }
    for (uint32_t z = 0; z < 20; z++) {
        const uint32_t a = hFunc(2 * z * RHO, mke);
        const uint32_t b = rol32(hFunc((2 * z * RHO + RHO), mko), 8);
        tfk0array[2 * z] = a + b;
        tfk0array[2 * z + 1] = rol32((a + 2 * b), 9);
    }
    for (i = 0; i < std::size(TFQ0ARRAY); i++) {
        uint8_t y0 = i;
        uint8_t y1 = i;
        uint8_t y2 = i;
        uint8_t y3 = i;
        y0 = tfq1array[y0] ^ (tfs0array[3] & 0xff);
        y1 = tfq0array[y1] ^ ((tfs0array[3] >> 8) & 0xff);
        y2 = tfq0array[y2] ^ ((tfs0array[3] >> 16) & 0xff);
        y3 = tfq1array[y3] ^ ((tfs0array[3] >> 24) & 0xff);
        y0 = tfq1array[y0] ^ (tfs0array[2] & 0xff);
        y1 = tfq1array[y1] ^ ((tfs0array[2] >> 8) & 0xff);
        y2 = tfq0array[y2] ^ ((tfs0array[2] >> 16) & 0xff);
        y3 = tfq0array[y3] ^ ((tfs0array[2] >> 24) & 0xff);
        y0 = tfq1array[tfq0array[tfq0array[y0] ^ (tfs0array[1] & 0xff)] ^ (tfs0array[0] & 0xff)];
        y1 = tfq0array[tfq0array[tfq1array[y1] ^ ((tfs0array[1] >> 8) & 0xff)] ^ ((tfs0array[0] >> 8) & 0xff)];
        y2 = tfq1array[tfq1array[tfq0array[y2] ^ ((tfs0array[1] >> 16) & 0xff)] ^ ((tfs0array[0] >> 16) & 0xff)];
        y3 = tfq0array[tfq1array[tfq1array[y3] ^ ((tfs0array[1] >> 24) & 0xff)] ^ ((tfs0array[0] >> 24) & 0xff)];
        tfqfarray[0][i] = static_cast<uint32_t>((tfq3array[y0] << 24) | (tfq3array[y0] << 16) |
            (tfq2array[y0] << 8) | y0);
        tfqfarray[1][i] = static_cast<uint32_t>((y1 << 24) | (tfq2array[y1] << 16) |
            (tfq3array[y1] << 8) | tfq3array[y1]);
        tfqfarray[2][i] = static_cast<uint32_t>((tfq3array[y2] << 24) | (y2 << 16) |
            (tfq3array[y2] << 8) | tfq2array[y2]);
        tfqfarray[3][i] = static_cast<uint32_t>((tfq2array[y3] << 24) |
            (tfq3array[y3] << 16) | (y3 << 8) | tfq2array[y3]);
    }
}

inline void TwofishInitialize(std::string s) {
    TwofishInitialize(std::vector<uint8_t>(s.begin(), s.end()));
}

